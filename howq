[1mdiff --git a/215.kth-largest-element-in-an-array.java b/215.kth-largest-element-in-an-array.java[m
[1mindex 4a0d0cc..c6c1d1c 100644[m
[1m--- a/215.kth-largest-element-in-an-array.java[m
[1m+++ b/215.kth-largest-element-in-an-array.java[m
[36m@@ -1,44 +1,37 @@[m
 [m
 class Solution {[m
 [m
[31m-    public int findKthLargest(int[] nums, int k) {[m
[31m-[m
[31m-        return findKth(nums, 0, nums.length - 1, nums.length - k);[m
[31m-    }[m
[31m-[m
[31m-    private int findKth(int [] nums, int lo, int hi, int k) {[m
[31m-        if(lo == hi) {[m
[31m-            return nums[lo];[m
[31m-        }[m
[31m-[m
[31m-        int p = partition(nums, lo, hi);[m
[31m-[m
[31m-        if(p == k) {[m
[31m-            return nums[k];[m
[31m-        } else if(p > k) {[m
[31m-            return findKth(nums, lo, p, k);[m
[31m-        } else {[m
[31m-            return findKth(nums, p + 1, hi, k);[m
[31m-        }[m
[31m-    }[m
[31m-[m
[31m-    private int partition(int [] nums, int lo, int hi) {[m
[31m-        int i = lo, j = hi, pivot = nums[hi];[m
[31m-[m
[31m-        while(i < j) {[m
[31m-            if(nums[i++] > pivot) {[m
[31m-                swap(nums, --i, --j);[m
[31m-            }[m
[31m-        }[m
[31m-[m
[31m-        swap(nums, i++, hi);[m
[31m-[m
[31m-        return i;[m
[31m-    }[m
[31m-[m
[31m-    private void swap(int [] nums, int i, int j) {[m
[31m-        int temp = nums[i];[m
[31m-        nums[i] = nums[j];[m
[31m-        nums[j] = temp;[m
[31m-    }[m
[32m+[m	[32mpublic int findKthLargest(int[] nums, int k) {[m
[32m+[m		[32mreturn quickselect(nums, k, 0, nums.length - 1);[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mpublic int quickselect(int[] nums, int k, int left, int right) {[m
[32m+[m
[32m+[m		[32mif (left >= right) return nums[left];[m
[32m+[m
[32m+[m		[32mint mid = left + (right - left)/2;[m
[32m+[m		[32mint last = left;[m
[32m+[m		[32mswap(mid, left, nums);[m
[32m+[m
[32m+[m		[32mfor (int i = left + 1; i <= right; i++){[m
[32m+[m			[32mif (nums[i] < nums[left]) swap(++last, i, nums);[m
[32m+[m		[32m}[m
[32m+[m
[32m+[m		[32mswap(last, left, nums);[m
[32m+[m
[32m+[m		[32mint l = right - last + 1;[m
[32m+[m		[32mif (l == k) {[m
[32m+[m			[32mreturn nums[last];[m
[32m+[m		[32m} else if (l > k) {[m
[32m+[m			[32mreturn quickselect(nums, k, last + 1, right);[m
[32m+[m		[32m} else {[m
[32m+[m			[32mreturn quickselect(nums, k-l, left, last - 1);[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
[32m+[m
[32m+[m	[32mpublic void swap(int a,int b,int[] nums){[m
[32m+[m		[32mint t = nums[a];[m
[32m+[m		[32mnums[a] = nums[b];[m
[32m+[m		[32mnums[b] = t;[m
[32m+[m	[32m}[m
 }[m
